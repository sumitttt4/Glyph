"use client";

import { useState, useCallback, useEffect, useRef } from 'react';
import { Sidebar, GenerationOptions } from '@/components/generator/Sidebar';
import { Toolbar } from '@/components/generator/Toolbar';
import { LoadingState } from '@/components/generator/LoadingState';
import { WorkbenchBentoGrid } from '@/components/generator/WorkbenchBentoGrid';
import { ProGateModal } from '@/components/generator/ProGateModal';
import { useBrandGenerator } from '@/hooks/use-brand-generator';
import { createClient } from '@/utils/supabase/client';
import { exportBrandPackage } from '@/lib/export';
import { generateFaviconPackage } from '@/lib/favicon-generator';
import { generateSocialMediaKit, downloadSocialAsset } from '@/lib/social-media-kit';
import { openBrandBookForPrint } from '@/lib/brand-book';
import { CompareOverlay } from '@/components/generator/CompareOverlay';
import { RobotEmptyState } from '@/components/generator/RobotEmptyState';
import { BrandIdentity } from '@/lib/data';

export default function GeneratorPage() {
  const brandGenerators = useBrandGenerator();
  // ... rest of component

  const { brand, generateBrand, isGenerating, resetBrand } = brandGenerators;
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [selectedVibe, setSelectedVibe] = useState('minimalist');
  const [viewMode, setViewMode] = useState<'overview' | 'presentation'>('overview');
  const [showProModal, setShowProModal] = useState(false);

  const [isPro, setIsPro] = useState(false);
  // Compare State
  const [compareList, setCompareList] = useState<BrandIdentity[]>([]);
  const [isCompareOpen, setIsCompareOpen] = useState(false);

  const handleAddToCompare = () => {
    if (!brand) return;
    if (compareList.find(b => b.id === brand.id)) {
      alert("This brand is already in your comparison list.");
      return;
    }
    if (compareList.length >= 4) {
      alert("You can compare up to 4 brands at a time.");
      return;
    }
    setCompareList([...compareList, brand]);
    // Optional feedback
    const btn = document.activeElement as HTMLElement;
    if (btn) {
      const originalText = btn.innerHTML;
      btn.innerHTML = "<span class='text-green-600'>Added!</span>";
      setTimeout(() => btn.innerHTML = originalText, 1000);
    }
  };

  const handleRemoveFromCompare = (id: string) => {
    setCompareList(prev => prev.filter(b => b.id !== id));
  };

  const mainRef = useRef<HTMLElement>(null);

  useEffect(() => {
    // Scroll to results on mobile when generation finishes
    if (!isGenerating && brand && window.innerWidth < 768) {
      mainRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }, [isGenerating, brand]);

  useEffect(() => {
    const checkAccess = async () => {
      // ADMIN BYPASS: Check cookie
      const hasAdminBypass = document.cookie.split(';').some(c => c.trim().startsWith('admin-bypass=true'));
      if (hasAdminBypass) {
        setIsPro(true);
        return;
      }

      const supabase = createClient();
      const { data: { user } } = await supabase.auth.getUser();

      // Grant Pro access to specific admin email
      if (user?.email === 'sumitsharma9128@gmail.com') {
        setIsPro(true);
      }
    };

    checkAccess();
  }, []);

  const handleGenerate = useCallback((options: GenerationOptions) => {
    generateBrand(options.vibe, options.name, {
      color: options.color,
      shape: options.shape,
      gradient: options.gradient,
      surpriseMe: options.surpriseMe
    });
  }, [generateBrand]);

  const handleExport = async (type: string) => {
    if (!brand) return;

    if (type === 'svg') {
      const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${brand.shape.viewBox || "0 0 24 24"}">
        <path d="${brand.shape.path}" fill="${brand.theme.tokens.light.primary}" />
      </svg>`;
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${brand.name.toLowerCase().replace(/\s+/g, '-')}-logo.svg`;
      link.click();
    } else if (type === 'tailwind') {
      const tokens = brand.theme.tokens;
      const config = `// ${brand.name} - Tailwind CSS Config
// Generated by Glyph

module.exports = {
  theme: {
    extend: {
      colors: {
        light: {
          background: "${tokens.light.bg}",
          foreground: "${tokens.light.text}",
          primary: "${tokens.light.primary}",
          surface: "${tokens.light.surface}",
          muted: "${tokens.light.muted}",
          border: "${tokens.light.border}",
        },
        dark: {
          background: "${tokens.dark.bg}",
          foreground: "${tokens.dark.text}",
          primary: "${tokens.dark.primary}",
          surface: "${tokens.dark.surface}",
          muted: "${tokens.dark.muted}",
          border: "${tokens.dark.border}",
        },
      },
    },
  },
};`;
      navigator.clipboard.writeText(config);
      alert('Tailwind config copied to clipboard!');
    } else if (type === 'react') {
      const componentCode = `// ${brand.name} Logo Component
// Generated by Glyph

interface LogoProps {
  className?: string;
  color?: string;
}

export function ${brand.name.replace(/\s+/g, '')}Logo({ className = "w-8 h-8", color = "${brand.theme.tokens.light.primary}" }: LogoProps) {
  return (
    <svg
      viewBox="${brand.shape.viewBox || "0 0 24 24"}"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={className}
    >
      <path d="${brand.shape.path}" fill={color} />
    </svg>
  );
}
`;
      navigator.clipboard.writeText(componentCode);
      alert('React component copied to clipboard!');
    } else if (type === 'all') {
      if (!isPro) {
        setShowProModal(true);
        return;
      }
      try {
        await exportBrandPackage(brand);
      } catch (error) {
        console.error("Export failed:", error);
        alert("Failed to create export package. Please try again.");
      }
    } else if (type === 'favicon') {
      // Generate and download favicon package
      const pkg = generateFaviconPackage(brand);
      const faviconSvg = pkg.files.find(f => f.name === 'favicon.svg')?.content || '';
      const blob = new Blob([faviconSvg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${brand.name.toLowerCase().replace(/\s+/g, '-')}-favicon.svg`;
      link.click();
      // Also copy HTML snippet to clipboard
      navigator.clipboard.writeText(pkg.htmlSnippet);
      alert('Favicon SVG downloaded! HTML snippet copied to clipboard.');
    } else if (type === 'social') {
      const assets = generateSocialMediaKit(brand);
      // For demo, just download the Twitter profile pic. In prod, we'd zip them.
      // But let's verify it works by downloading the first few assets
      assets.slice(0, 3).forEach((asset, i) => {
        setTimeout(() => downloadSocialAsset(asset, brand.name), i * 300);
      });
      alert('Downloading Social Media assets...');
    } else if (type === 'brandbook') {
      openBrandBookForPrint(brand);
    }
  };

  return (
    // Mobile: Vertical stack, Desktop: Fixed sidebar + scrollable main
    <div className="min-h-screen w-full bg-stone-50 font-sans">
      <LoadingState isLoading={isGenerating} />
      <ProGateModal
        isOpen={showProModal}
        onClose={() => setShowProModal(false)}
        featureName="Full Package Export"
      />

      {/* Sidebar - Fixed on desktop, normal flow on mobile */}
      <div className="md:fixed md:left-0 md:top-0 md:bottom-0 md:w-[420px] md:overflow-y-auto overflow-x-hidden md:border-r md:border-stone-200 z-40 scrollbar-hide">
        <Sidebar
          onGenerate={handleGenerate}
          isGenerating={isGenerating}
          selectedVibe={selectedVibe}
          setSelectedVibe={setSelectedVibe}
          hasGenerated={!!brand}
        />
      </div>

      {/* Main Content - Has left margin on desktop to account for fixed sidebar */}
      <main ref={mainRef} className="relative bg-[#FAFAF9] min-h-screen md:ml-[420px]">
        <div
          className="absolute inset-0 opacity-40"
          style={{
            backgroundImage: 'radial-gradient(#A8A29E 1px, transparent 1px)',
            backgroundSize: '24px 24px',
          }}
        />

        {/* Toolbar - Sticky on mobile */}
        <div className="sticky md:absolute top-0 md:top-6 right-0 md:right-8 z-30 p-3 md:p-0 bg-stone-50/80 md:bg-transparent backdrop-blur-sm md:backdrop-blur-none flex justify-end">
          <Toolbar
            isDark={isDarkMode}
            toggleDark={() => setIsDarkMode(!isDarkMode)}
            onExport={handleExport}
            viewMode={viewMode}
            setViewMode={setViewMode}
            canUndo={brandGenerators.canUndo}
            canRedo={brandGenerators.canRedo}
            onUndo={brandGenerators.undo}
            onRedo={brandGenerators.redo}
            currentHistoryIndex={brandGenerators.historyIndex}
            totalHistory={brandGenerators.historyTotal}
            onAddToCompare={brand ? handleAddToCompare : undefined}
            onOpenCompare={() => setIsCompareOpen(true)}
            compareCount={compareList.length}
          />
        </div>

        <CompareOverlay
          brands={compareList}
          isOpen={isCompareOpen}
          onClose={() => setIsCompareOpen(false)}
          onRemove={handleRemoveFromCompare}
        />

        <div className={`relative z-10 transition-all duration-500 w-full min-h-full pt-4 md:pt-20 pb-20 px-2 md:px-0 ${isDarkMode ? 'dark' : ''}`}>
          {brand ? (
            <WorkbenchBentoGrid
              brand={brand}
              isDark={isDarkMode}
              onShuffleLogo={() => generateBrand(selectedVibe, brand.name)}
              viewMode={viewMode}
              setViewMode={setViewMode}
            />
          ) : (
            <RobotEmptyState />
          )}
        </div>
      </main>
    </div>
  );
}


