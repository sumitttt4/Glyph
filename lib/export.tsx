import React from 'react';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { BrandIdentity } from '@/lib/data';
import { renderToStaticMarkup } from 'react-dom/server';
import { MonogramMark } from '@/components/brand/MonogramMark';

export async function exportBrandPackage(brand: BrandIdentity) {
  const zip = new JSZip();
  const folderName = brand.name.toLowerCase().replace(/\s+/g, '-');
  const root = zip.folder(folderName);

  if (!root) {
    console.error("Failed to create zip folder");
    return;
  }

  // 1. ICONS / LOGOS
  const icons = root.folder("icons");
  if (icons) {
    // A. Primary Logo (Color)
    const primarySvg = renderToStaticMarkup(
      <MonogramMark
        brand={brand}
        color={brand.theme.tokens.light.primary}
        bg={brand.theme.tokens.light.surface}
      />
    );
    // Wrap in standard SVG tag if not present (MonogramMark returns a div wrapper, we need to extract SVG or render it wrapped)
    // MonogramMark returns a DIV with SVG inside. We need to clean this up for export.
    // Actually, for a pure SVG export, we don't want the container div.
    // The MonogramMark component returns a <div> with <svg> inside.
    // We should probably modify MonogramMark to return just SVG if requested, or parse the string.
    // For now, let's wrap it in an SVG "File" structure if needed, or just cleaner regex extract.
    // A simple way is to use a specific props to output ONLY svg?
    // Or regex extract <svg ... </svg>
    const primarySvgString = extractSvg(primarySvg);
    icons.file("logo-primary.svg", primarySvgString);

    // B. Monotone Black
    const blackSvg = renderToStaticMarkup(
      <MonogramMark
        brand={brand}
        color="#000000"
        bg="transparent"
      />
    );
    icons.file("logo-black.svg", extractSvg(blackSvg));

    // C. Monotone White
    const whiteSvg = renderToStaticMarkup(
      <MonogramMark
        brand={brand}
        color="#FFFFFF"
        bg="transparent"
      />
    );
    icons.file("logo-white.svg", extractSvg(whiteSvg));
  }

  // 2. TOKENS / CODE
  const tokens = root.folder("tokens");
  if (tokens) {
    // A. theme.json
    tokens.file("theme.json", JSON.stringify(brand.theme, null, 2));

    // B. tailwind.config.js
    const tailwindConfig = `/** @type {import('tailwindcss').Config} */
module.exports = {
  theme: {
    extend: {
      colors: {
        brand: {
          50: '${brand.theme.tokens.light.bg}',
          100: '${brand.theme.tokens.light.surface}',
          500: '${brand.theme.tokens.light.primary}',
          900: '${brand.theme.tokens.light.text}',
        }
      },
      fontFamily: {
        sans: ['${brand.font.name}', 'sans-serif'],
      }
    },
  },
}`;
    tokens.file("tailwind.config.js", tailwindConfig);

    // C. css-variables.css
    const cssVars = `:root {
  --brand-primary: ${brand.theme.tokens.light.primary};
  --brand-bg: ${brand.theme.tokens.light.bg};
  --brand-surface: ${brand.theme.tokens.light.surface};
  --brand-text: ${brand.theme.tokens.light.text};
  --font-heading: '${brand.font.name}';
  --font-body: '${brand.font.name}';
}`;
    tokens.file("variables.css", cssVars);
  }

  // 3. README
  const readme = `
# ${brand.name} Brand Identity
Generated by Glyph (https://glyph.software)

## Contents
- /icons: SVG vector logo files (Primary, Black, White).
- /tokens: Development tokens for Tailwind CSS and CSS variables.

## Usage
- Use 'logo-primary.svg' for white/light backgrounds.
- Use 'logo-white.svg' for dark backgrounds.
- Always maintain clear space around the logo.

## Fonts
Primary Font: ${brand.font.name}
This brand uses Google Fonts. You may need to license them for offline use.
`;
  root.file("README.txt", readme.trim());

  // GENERATE ZIP
  const content = await zip.generateAsync({ type: "blob" });
  saveAs(content, `${folderName}-assets.zip`);
}

// Helper to extract SVG from the React render string (which includes a wrapper div)
function extractSvg(html: string): string {
  const match = html.match(/<svg[\s\S]*?<\/svg>/);
  return match ? match[0] : html;
}
